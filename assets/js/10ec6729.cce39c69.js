"use strict";(self.webpackChunkece_178_notes=self.webpackChunkece_178_notes||[]).push([[510],{2183:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=i(4848),s=i(8453);const a={},r="Advanced Image Processing",o={id:"programming-help/advanced-image-processing",title:"Advanced Image Processing",description:"Image Processing with Scipy and Numpy",source:"@site/docs/programming-help/advanced-image-processing.mdx",sourceDirName:"programming-help",slug:"/programming-help/advanced-image-processing",permalink:"/docs/programming-help/advanced-image-processing",draft:!1,unlisted:!1,editUrl:"https://github.com/amilworks/ece178/edit/main/ece-178-notes/docs/programming-help/advanced-image-processing.mdx",tags:[],version:"current",lastUpdatedBy:"amilworks",lastUpdatedAt:1708489637,formattedLastUpdatedAt:"Feb 21, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction to Python",permalink:"/docs/programming-help/intro-to-python"}},l={},c=[{value:"Image Processing with Scipy and Numpy",id:"image-processing-with-scipy-and-numpy",level:2},{value:"Filtering with scipy",id:"filtering-with-scipy",level:3},{value:"Edge Detection",id:"edge-detection",level:3},{value:"Image Segmentation with K-means Clustering",id:"image-segmentation-with-k-means-clustering",level:3},{value:"Morphological Operations",id:"morphological-operations",level:3},{value:"Fourier Transform",id:"fourier-transform",level:2},{value:"Low-Pass Filtering using Fourier Transform",id:"low-pass-filtering-using-fourier-transform",level:3},{value:"High-Pass Filtering for Edge Detection",id:"high-pass-filtering-for-edge-detection",level:3},{value:"Band-Pass Filtering",id:"band-pass-filtering",level:3}];function f(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"advanced-image-processing",children:"Advanced Image Processing"}),"\n",(0,t.jsx)(n.h2,{id:"image-processing-with-scipy-and-numpy",children:"Image Processing with Scipy and Numpy"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"scipy"})," extends ",(0,t.jsx)(n.code,{children:"numpy"}),"'s capabilities, providing a wide range of image processing functions, including filtering, morphology, and feature extraction."]}),"\n",(0,t.jsx)(n.h3,{id:"filtering-with-scipy",children:"Filtering with scipy"}),"\n",(0,t.jsxs)(n.p,{children:["Filters are used to enhance or suppress details in an image. ",(0,t.jsx)(n.code,{children:"scipy"})," offers functions for various filters:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from scipy.ndimage import gaussian_filter\n\n# Apply a Gaussian blur to the image\nblurred = gaussian_filter(grayscale, sigma=2)\nplt.imshow(blurred, cmap='gray')\nplt.show()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"edge-detection",children:"Edge Detection"}),"\n",(0,t.jsxs)(n.p,{children:["Edge detection is a fundamental task in image processing, used to identify significant transitions in intensity. ",(0,t.jsx)(n.code,{children:"scipy"})," can perform edge detection using the Sobel filter:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from scipy.ndimage import sobel\n\n# Apply Sobel filter to detect edges\nsx = sobel(grayscale, axis=0, mode='constant')\nsy = sobel(grayscale, axis=1, mode='constant')\nedges = np.hypot(sx, sy)\nplt.imshow(edges, cmap='gray')\nplt.show()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"image-segmentation-with-k-means-clustering",children:"Image Segmentation with K-means Clustering"}),"\n",(0,t.jsx)(n.p,{children:"Image segmentation partitions an image into multiple segments or pixels sets to simplify its representation. K-means clustering is a popular method for segmentation due to its simplicity and efficiency."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from sklearn.cluster import KMeans\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef segment_image(image, n_clusters=3):\n    # Flatten the image\n    pixels = image.reshape((-1, 3))\n    \n    # Apply K-means clustering\n    kmeans = KMeans(n_clusters=n_clusters, random_state=0).fit(pixels)\n    segmented_img = kmeans.cluster_centers_[kmeans.labels_]\n    \n    # Reshape back to the original image shape\n    segmented_img = segmented_img.reshape(image.shape)\n    return segmented_img\n\n# Load and segment the image\nimage = plt.imread('path/to/image.jpg')\nsegmented_image = segment_image(image, n_clusters=3)\n\n# Display the original and segmented image\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].imshow(image)\nax[0].set_title('Original Image')\nax[0].axis('off')\n\nax[1].imshow(segmented_image.astype('uint8'))\nax[1].set_title('Segmented Image')\nax[1].axis('off')\n\nplt.show()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"morphological-operations",children:"Morphological Operations"}),"\n",(0,t.jsx)(n.p,{children:"Morphological operations process images based on shapes. They apply a structuring element to an input image, creating an output image of the same size."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from scipy.ndimage import binary_opening, generate_binary_structure\n\n# Apply morphological opening to remove small objects from the image\nstruct = generate_binary_structure(2, 1)  # 2D structuring element\nopened_image = binary_opening(edges, structure=struct).astype(np.int)\n\n# Display the result\nplt.imshow(opened_image, cmap='gray')\nplt.title('Morphological Opening')\nplt.axis('off')\nplt.show()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"fourier-transform",children:"Fourier Transform"}),"\n",(0,t.jsx)(n.p,{children:"The Fourier Transform is used in image processing for frequency analysis, filtering, and even image compression and restoration."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from scipy.fft import fft2, fftshift\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Compute the 2D Fourier Transform of the image\nf_transform = fft2(grayscale)\nf_shifted = fftshift(f_transform)  # Shift the zero frequency component to the center\nmagnitude_spectrum = 20 * np.log(np.abs(f_shifted))\n\n# Display the magnitude spectrum\nplt.imshow(magnitude_spectrum, cmap='gray')\nplt.title('Magnitude Spectrum')\nplt.axis('off')\nplt.show()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"low-pass-filtering-using-fourier-transform",children:"Low-Pass Filtering using Fourier Transform"}),"\n",(0,t.jsx)(n.p,{children:"Low-pass filtering allows only the low-frequency components of an image to pass through and can be used for blurring and noise reduction."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from scipy.fft import fft2, ifft2, fftshift, ifftshift\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef low_pass_filter(image, cutoff_frequency):\n    # Compute the 2D Fourier Transform\n    f_transform = fft2(image)\n    f_shifted = fftshift(f_transform)\n    \n    # Create a mask with high value (1) at low frequency and low value (0) at high frequency\n    rows, cols = image.shape\n    crow, ccol = rows // 2, cols // 2\n    mask = np.zeros((rows, cols), np.uint8)\n    mask[crow - cutoff_frequency: crow + cutoff_frequency, ccol - cutoff_frequency: ccol + cutoff_frequency] = 1\n    \n    # Apply mask and inverse DFT\n    f_shifted_filtered = f_shifted * mask\n    f_inverse_shifted = ifftshift(f_shifted_filtered)\n    img_filtered = ifft2(f_inverse_shifted)\n    img_filtered = np.abs(img_filtered)\n    \n    return img_filtered\n\n# Example usage\ngrayscale = plt.imread('path/to/grayscale/image.png')\nfiltered_image = low_pass_filter(grayscale, cutoff_frequency=30)\n\nplt.figure(figsize=(10,5))\nplt.subplot(121), plt.imshow(grayscale, cmap='gray'), plt.title('Original')\nplt.subplot(122), plt.imshow(filtered_image, cmap='gray'), plt.title('Low-Pass Filtered')\nplt.show()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"high-pass-filtering-for-edge-detection",children:"High-Pass Filtering for Edge Detection"}),"\n",(0,t.jsx)(n.p,{children:"High-pass filtering enhances or detects high-frequency components in an image, useful for edge detection and sharpening."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def high_pass_filter(image, cutoff_frequency):\n    # Compute the 2D Fourier Transform\n    f_transform = fft2(image)\n    f_shifted = fftshift(f_transform)\n    \n    # Create a mask with low value (0) at low frequency and high value (1) at high frequency\n    rows, cols = image.shape\n    crow, ccol = rows // 2, cols // 2\n    mask = np.ones((rows, cols), np.uint8)\n    mask[crow - cutoff_frequency: crow + cutoff_frequency, ccol - cutoff_frequency: ccol + cutoff_frequency] = 0\n    \n    # Apply mask and inverse DFT\n    f_shifted_filtered = f_shifted * mask\n    f_inverse_shifted = ifftshift(f_shifted_filtered)\n    img_filtered = ifft2(f_inverse_shifted)\n    img_filtered = np.abs(img_filtered)\n    \n    return img_filtered\n\n# Example usage\nfiltered_image = high_pass_filter(grayscale, cutoff_frequency=30)\n\nplt.figure(figsize=(10,5))\nplt.subplot(121), plt.imshow(grayscale, cmap='gray'), plt.title('Original')\nplt.subplot(122), plt.imshow(filtered_image, cmap='gray'), plt.title('High-Pass Filtered')\nplt.show()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"band-pass-filtering",children:"Band-Pass Filtering"}),"\n",(0,t.jsx)(n.p,{children:"Band-pass filtering allows frequencies within a certain range to pass through, which can be useful for isolating specific features or frequency ranges in an image."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def band_pass_filter(image, low_cutoff, high_cutoff):\n    # Compute the 2D Fourier Transform\n    f_transform = fft2(image)\n    f_shifted = fftshift(f_transform)\n    \n    # Create a band-pass mask\n    rows, cols = image.shape\n    crow, ccol = rows // 2, cols // 2\n    mask = np.zeros((rows, cols), np.uint8)\n    mask[crow - high_cutoff: crow + high_cutoff, ccol - high_cutoff: ccol + high_cutoff] = 1\n    mask[crow - low_cutoff: crow + low_cutoff, ccol - low_cutoff: ccol + low_cutoff] = 0\n    \n    # Apply mask and inverse DFT\n    f_shifted_filtered = f_shifted * mask\n    f_inverse_shifted = ifftshift(f_shifted_filtered)\n    img_filtered = ifft2(f_inverse_shifted)\n    img_filtered = np.abs(img_filtered)\n    \n    return img_filtered\n\n# Example usage\nfiltered_image = band_pass_filter(grayscale, low_cutoff=10, high_cutoff=50)\n\nplt.figure(figsize=(10,5))\nplt.subplot(121), plt.imshow(grayscale, cmap='gray'), plt.title('Original')\nplt.subplot(122), plt.imshow(filtered_image, cmap='gray'), plt.title('Band-Pass Filtered')\nplt.show()\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(f,{...e})}):f(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);